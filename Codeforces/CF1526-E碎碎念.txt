n<=2*1e5,k<=2*1e5

给定一个0~n-1的全排列，问用字符集大小为k的字符集，能构造出多少个字符串使得其后缀数组与输入相等

一看到这个题我就感觉不会做，因为我连后缀数组的模板都不会
那么我的信念是否正确呢

让我做一做来check一下~

n=2的情况
s=ab
如果是[0,1]
说明ab<b

如果是[1,0]
说明b<ab


考虑后缀树

设s的字符集合为sigma
对于sigma中的最小字符，设为a
假设a在s中出现了c(a)次
那么后缀数组的第一个标号一定是这些位置的下标之一
继续看这些位置后面第二个字符


等下，这似乎与后缀前缀没啥关系，把后缀替换成前缀，问题是一样的

不一样，因为如果取前缀的话，我们应当从前缀的后面开始出发比较。

所以还是用后缀来思考吧

考虑最简单的情况
[0,1,...,n-1]
那么所有非降序字符串都满足

数量是多少？
感觉这个数量都很难计算呢，看来这题是没法做了

dp[i][j]=sum dp[i-1][u] u from j to k
这个是O(NK)级别的

即使是算严格上升的字符串数量
我好像也不会

等下，似乎这个k不重要，重要的是如果严格上升的话，那么n一定<=k，在k中取n个不同数字，sort后就是严格上升的字符串（反过来能也一一对应）
C(k,n)（注意不是C(n,k)）

不严格上升，似乎就是在n*k个数字中（每种数字复制n个），取n个数字，然后sort后就是非严格上升的字符串
反过来不能一一对应。。

还是check一下题解吧

hint1说尝试考虑最小可能的k
比如对于[0,1]，k一定>1，因为k=1的话，a<aa，应为[1,0]，但是k=2就可以了

可以考虑一下数组的逆序对和正序对
如果数组中i排在j之前，且i<j，说明后缀j一定不是后缀i的前缀

check~check~ 别僵在这里

emm，似乎发现这个最小k与全排列序号可能有关系
[1,0,2]

0 [0,1,2]
1 [0,2,1]
2 [1,0,2]
3 [1,2,0]
4 [2,0,1]
5 [2,1,0]

则[1,0,2]序号为2
那么min k可以为2吗？好像还不可以。。肯定>2

让我们考虑两个相邻数字i和i+1，设在数组中的下标为p(i),p(i+1)
如果p(i)<p(i+1)，那么似乎后缀i一定是个非严格上升且至少有两个不同字符的字符串
反过来如果后缀i满足这样的性质，那么一定有p(i)<p(i+1)

[0,2,1]
p(0)<p(1), s=aab,=abb
但是因为p(2)<p(1)，所以s只能=abb


如果p(i)>p(i+1)
设s[i+1]=c，
可能的情况
	s[i]>c
	s[i]==c,后缀i+1全是相等的字符c

假设p(0)<p(1)，但是p(0)和p(1)不相邻，所以[p(0)+1,p(1)-1]之间的数字i>1，一定有p(0)<p(i)和p(1)>p(i)

怎么又分析起来了
感觉算法题试探思路的话，分析不如构造有用

[0,3,2,1]
p(0)<p(1)，所以后缀0非严格上升，至少有两个不同字符
p(1)>p(2)，所以后缀1要么s[1]>s[2]，要么后缀1全部字符相等
p(2)>p(3)，所以后缀2要么s[2]>s[3]，要么后缀2全部字符相等
p(0)<p(3)，说明s[0]<s[3]

可能的模式
abbb

另一个角度
我们把数组划分成若干连续段，每段数字（作为字符串下标）对应的字符都是相同的
那么我们就构造出了模式，如果有m段的，对应字符串数量就是C(k,m)
问题是什么样的段划分是可行的

换个角度，什么样的段划分一定不可行？

算了算了
还是check

我没有把关注点放在 数组中的相邻对，而是数轴上的相邻数字了
并且在比较两个后缀的时候，没有把这一个pair的比较转移到长度都分别减一的pair的比较

但是为啥有>k个first>second的pair就一定不可能呢？
这些pair又不一定首尾相连

虽然不一定首尾相连，但是！在后缀数组中的i,j如果i在j前面，那么s[i]一定<=s[j]！
所以一个pair就意味着一个至少字符+1的跳跃（即使没有pair也至少<=）
这样的跳跃最多k-1次

反过来如果跳跃次数<=k-1的话，就一定有解吗？
对于首字符可能可以相等的后缀数组中的区间

感觉这个存在性可以用归纳法来证明
假设对于长度为n-1的数组，只要pair数量<=k-1，就一定有解
那么对于长度为n的数组，

如果
长度为3，下标从0~2
如果是[0,1,2]
如果pair(0,1)
那么ab*
abb或者abc即可

如果是[0,2,1]
那么我们就不讨论(0,1)的pair是否存在了，我们只讨论(0,2)和(2,1)
如果pair(0,2)（pair(i,j)意味着s[i+1]>=s[j+1]&&s[i]<s[j]，也就是说如果pair(i,j)则一定!pair(i+1,j+1)）
那么a*b

区间太难想了
想后缀树，把叶子节点排序
考虑两个相邻后缀的LCP，那么删去前LCP个字符得到的两个新的后缀也一定。。是相邻的吗？
恐怕不一定

但是顺序一定是保持的

卧槽我没意识到一个简单的事实：所有的后缀都是不等长，因此任意两个后缀字符串一定不相等！
所以要么>要么<
而对于后缀数组中的数字i,j，i在j前面
如果s[i]!=s[j]，那么一定是s[i]<s[j]
如果s[i]==s[j]，那么一定是后缀i+1<后缀j+1

而给定后缀数组，我们是可以check两个后缀的大小的！第二种情况的后件可以check，那么转逆否命题，就可以check条件，得到结论了
即：
如果后缀i+1>后缀j+1，排除第二种可能，那么一定s[i]<s[j]
如果检查后发现后缀i+1并不>后缀j+1，一定意味着后缀i+1<后缀j+1，此时s[i]只要<=s[j]即可

而为了不超过字符集的大小，能相等的就相等，实在不能相等的，比如要求s[i]<s[j]的，才把字符+1
如果这样的跳跃<=k-1，最终一定存在字符串满足对应的后缀数组

怎么计算呢？恐怕我想到这一点也会在计算上卡死
就是把跳跃转换为差分数组
设初始值为零，那么差分数组就是n个数字，a[1]~a[n]，代表s[i]=sum a[1]~a[i]
且在跳跃点(i,i+1)处，要求a[i+1]>=1
而总sum<=k，因此可以转化为隔板法解决
设有k个元素，我们在其中插入n个隔板，相邻隔板之间的元素数量就是右边隔板对应的数字
但是，这样不能表示在同一个空位插入多个隔板
也不能表示a[i+1]>=1
第一个问题可以通过重新约定编码方式解决，
我们把总元素个数增加到k+n
隔板编号 0~n-1
隔板i-1和隔板i之间的数字算给i，但是要减去i
这样似乎不能一一对应，这样可能会出现负数

我们把总元素个数增加到k+n
隔板i-1和隔板i之间的数字算给i，但是要减去1
且只能在每个元素右空位插空
这样就解决了第一个问题

对了那个cnt不应该是pair个数，而是pair个数+1，跳跃数+1才是最小种类数

a[i]>=1的话，似乎直接约定第i个隔板的数字要加一即可
为了不超过k，因此总个数又要-=cnt，cnt为所有a[i]>=1的i个数
所以最后的结果就是C(k+n+1-cnt,n)
直接算是O(N^2)，空间也爆了
但是我们只需要在模的条件下输出
因此O(N)预处理阶乘和它的逆（线性求逆元或者Nlog(MOD)求逆元）

线性求逆元的文章
https://blog.csdn.net/qq_34564984/article/details/52292502
思路就是构造递推式
inv[i]怎么和一个j<i的inv[j]建立等式
把模数M用i除，余数为j
那么M=k*i+j （以下都在Mod M意义下讨论）
那么k*i=-j, i=-j/k 
1/i=-k/j
也就是inv[i]=-k*inv[j]=-(M/i)inv[M%i]
或者添加上M的倍数凑正
inv[i]=(M-(M/i))inv[M%i]