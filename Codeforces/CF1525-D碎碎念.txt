给定n<=5000个位置，有m个不超过一半的位置上有人，每次可以把一个人移动到另一个空位，距离为代价
求最少代价让初始有人的位置全变空

因为一开始不超过一半位置有人，所以把这些人放到剩余位置中是足够的，一定有解

如果一开始有人的位置都是奇数，或者都是偶数，那么我们只需要花费m代价把人移动相邻偶数/奇数位置上
这也是下界，因此这是最小值

考虑两个人i和j，i<j，那么移动到的位置为to[i],to[j]应当有to[i]<to[j]
否则不是最优的，想象一下，就会发现边会交叉，我们可以swap(to[i],to[j])

所以对于有人的位置i1,i1,...,im,（从小到大） 应当有to[i1]<to[i2]<...<to[im]


考虑包含了所有有人位置的极小区间[l,r]
约定，[l,r]中初始有人位置为A类，最终有人位置为B类，始终无人为C类
在一种方案中，
	如果最后所有[l,r]中的空位并没有被全部填满，且[l,r]外有位置上有人
		那么我们总是可以找到一个不会更差的方案，满足[l,r]外位置有人的必要条件是[l,r]中的空位被填满
		我们可以对区间外的有人位置个数k应用归纳法来证明
		假设对于k=k'的情况，我们总能找到如上所述的替代方案
		那么对于k=k'+1的情况，不妨设<l的部分有位置有人
			找到[l,r]中第一个C类点，显然它不是l，
				如果它左侧邻点是A类点x，那to[x]改为它不会更差
				如果它左侧邻点是B类点x，...，找到反例
		我们不一定总是可以找到一个不会更差的方案，满足[l,r]外位置有人的必要条件是[l,r]中的空位被填满

有人 <=> 1

对于一段连续1段，对应to的方向要么L要么R，那么应当是LLL...RRR，不会出现RL的情况（否则边交叉，swap）
那么L和R的分界点是？
如果左右0位都是无限的，那么分界点就是中轴或者中点

构造一个贪心算法，
灰色，待配对的value=1的数字的数组下标（一开始把所有a[i].value=1的color=grey）
黑色，已经配对的value=1的数字的数组下标
从左往右扫描数组，如果当前a[i].value=1，且往左第一个color!=black && value=0的下标为j，那么a[i].cost=|i-j|，并且把a[i].color=black，如果往左找不到这样的j，那么a[i].cost=inf，a[i].color=grey
如果当前a[i].value=0,且往左第一个color==grey的value=1的下标为j，那么a[j].cost=|i-j|，并且设置a[i].color=a[j].color=black，...

突然又想到了反例


不过之前的努力并不是白费的，现在知道了对于连续1段[l,r]，可以分成两段，前面的都是L，后面的都是R，并且设前面L个数为k1，后面R个数为k2，那么[l-k1,l-1]都是B类，[r+1,r+k2]都是B类

我们可以这样DP，设第j个1段的pos为pos[j], 设f[i][j]表示以pos[j]-l为开头的数组后缀，把里面的人移动初始位置之外的最小代价，如果无法实现则为inf
那么我们就预处理每个1段的左右0段长度，然后枚举k1（或k2），从而把B类点给删除，转移到下一个后缀


所需数据：n,m（1个数）,a[],pos[],len[],lenl[],lenr[],f[][]

但是转移要O(N)，状态又是O(N^2)，所以是O(N^3)...

感觉枚举k这一个环节可以研究一下，变成>>斜率优化？

而且这个cost函数的确是平方形式。。

等下，这个k始终不超过len[i]的，因此算复杂度，每次不能算O(N)，实际上是累加起来是O(N)
所以还是O(N^2)的

但是算法也有bug，我们想的都是连续1段的移动位置与原段依然构成连续段的情况
所以还得欠。。也就是j可能变负，表示不仅左边没空位还欠一些1位没有移

还不够，我们不仅右移可以欠账，左移也应该可以欠账，至少是一开始最左边还很多的情况

那这样就比较棘手了

似乎O(N^2)的话，可以用一个非常简单的DP
f[i][j]表示从左往右处理到第i个点（应当是空位，否则令f[i][j]=f[i+1][j]），且左边已经选好了j个空位的情况下，能达到的最小代价

AC了，就这么个水题被我想复杂了

