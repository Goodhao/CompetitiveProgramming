给定两个字符串a,b
每次操作可以取一个字符串的子串升序排序
f(a,b)为最少操作次数，让两个字符串相等
不可能则f(a,b)=1337

给定n个字符串s1,s2,...,sn（等长，两两不同）
你需要计算 sum_{i=1}^n sum_{j=i+1}^n f(s_i,s_j)

反正这个暴力很简单

哦不 不简单，f怎么算

哦，似乎如果两个字符串字符集不同，那么一定无解，否则f(a,b)<=2，因为我们最多把两个字符串都排序一遍一定会一样
f取值就这么几种
f(a,b)=0,1,2,1337

但是一堆字符串的话，就不能只考虑一个pair的情况了，局部最优不等于全局最优

首先，按照字符集划分等价关系，不同等价类之间的元素的f一定是1337
同一等价类中可以独立处理

所以我们只考虑所有字符串字符集都等价的情况

考虑就两个字符0和1的情况


n=3

000111
110001
001101

等下，题意似乎理解错了，排序只是为了计算f，f计算完排序的效果不会保留，还是原串

那么只要考虑f(a,b)即可
判断f(a,b)能否=0很简单，完全一样才可以做到
判断f(a,b)能否=2也很简单，必定可以
所以只要判断f(a,b)能否=1，也就是说取一个字符串的子串排序后两者就一样了

假设取a[i]~a[j]排序，那么意味着a[1]~a[i-1]=b[1]~b[i-1]，a[i+1]~a[n]=b[i+1]~b[n]
且b[i]~b[j]本来就是升序的
反过来，如果b满足这样的条件（b[i]~b[j]本来就是升序的，前缀后缀与a一样），那么f(a,b)一定能=1

因为pair数量是O(N^2)的，不可能两两枚举，只能枚举一个i一次性算一堆j的sum

如果排序a[i]~a[j]后a=b，那么取区间[i',j']，包含了[i,j]的，也一定可以排序后使得a=b
只不过a[i']=b[i']，有点浪费，所以我们不妨只看那些从左第一个a[i]!=b[i],从右第一个a[j]!=b[j]的区间，这样的区间如果有一定是唯一，去check它

既然追求极大的前缀、后缀一样，那么用Trie树来想问题

对于si,sj，Trie树的公共前缀不用管，只用管分支后的两个后缀s'i,s'j
找出s'i,s'j的极大公共后缀，从而我们得到了一个中间的区间，去检查si或sj的这个区间上是否是升序的，升序也可以通过预处理扫一遍极大升序子区间，判断区间包含关系来判断

（可以把极大升序区间端点标记在Trie树上？）

枚举si，在Trie树上枚举si的所有极大升序区间(xi,yi)，总复杂度<=n|s|<=2*10^5
起点xi，对于xi子树的所有可接受点u
如果u和xi的最大后缀p已经有p<yi了，那么f(si,su)<=1（=0的情况可以预处理排除）
所以f(si,su)=1

我们就是要找到底有多少个u是满足p<yi的

树的结构保证了这个p可能<yi但绝不会<xi，否则，si=su
也就是说，后缀都被关在xi子树内部了，复杂度由此控制住了

那么大致思路已经成形了


好像关键的步骤想错了啊
后缀都被关在xi子树内部了，复杂度由此控制住了，这是错的
只能说对于si，任意的sj只需要检查从与si的公共前缀开始的部分的最大后缀长度
但是依然需要O(N^2)枚举(i,j)并不是像我想的那样划分子树，各自为政
（对于一个固定的i来说，是可以用si的区间来划分子树，各自为政的）


看了题解，发现就是用hash和根号分治
根号分治，真的妙，对于一堆字符串长度之和为定值的，需要枚举si和sj，也需要枚举一个字符串的区间的，似乎总是有奇效


不过还是要学一波LCP，求任意两个字符串的最大公共前缀
这样就可以找出任意两个字符串的需要check中间段（无视最大公共前缀和最大公共后缀）
可以O(N^2)枚举，然后O(logN)二分枚举那个最大长度，用hash来check
总体O(N^2logN)预处理所有字符串对的最大公共前缀

但是有更好的办法
注意到一个性质，如果我们把字符串按字典序排序的话，
固定i，si与sj(j>i)的LCP一定随着j变大而减小（或者不变），也就是非严格递减
因为一旦sj的原来LCP位上的字符变化了之后，只能越变越大，（或者进位后缩小，但此时更左边的位置也变大了），回不去了
进一步发现，排序后LCP(si,sj)=min{LCP(si,s(i+1)),LCP(s(i+1),s(i+2)),...,LCP(s(j-1),sj)}
变成求区间最值问题

如果用线段树的话，O(N^2)个请求，每次O(logN)，还是O(N^2logN)的
不过既然我们要O(N^2)个请求，直接离线处理，固定左端点，移动右端点，常见的区间操作优化。
可以做到O(N^2)

感觉还是没想清楚

设字符串长度为M（都一样）
N*M=K<=2*10^5
如果
	N<=sqrt(K)，则M>=sqrt(K)
	O(NMlogN)把所有字符串按前缀升序排序或者按后缀升序排序
	对于相邻的字符串，扫一遍计算它们的LCP或LCS，每个字符串最多与两个字符串相邻，
	也就是说最多被扫两次，总体O(NM)
	对于字符集大小相同的字符串，插入到同一个map中
	把每个字符串排序成字典序最小的字符序列需要O(NMlogM)，map中最后有N个元素，每次插入需要logN次比较，而字符串比较一次O(M)
	因此插入部分需要O(NMlogN)，复制的部分是O(NM)
	枚举同一个map中的任意两个字符串，O(N^2)，去掉它们的LCP和LCS后，判断是否有一段已经升序，而上升区间可以预处理，O(NM)
	注意M可以很大，可以接近K，所以我们不能开二维数组存上升区间，下标开不下，只能存vector用二分搜索来找，因此实际上是O(NMlogM)
	这样就处理完这部分了
	总复杂度是O(N^2+NMlog(NM))=O(NMlog(NM))

如果  N>sqrt(K)，则M<sqrt(K)
	此时枚举O(N^2)是不合适了
	但此时M就特别小，对于每个字符串si，我们可以O(M^2)枚举区间，然后把区间内的字符都sort（统计各个字符数量后基数排序即可）后，看看新的字符串是否已经在set内了（可以用hash来实现O(1)查询）
	总复杂度是O(NM^2)=O(Ksqrt(K))


写了一半，发现N>sqrt(K)的部分sort的复杂度很难处理到O(1)
好像我们没必要用sqrt(K)来划分，因为第一部分我们要控制的是O(N^2)
所以N可以更大一点，N<=sqrt(1e8)
这样第二部分N>sqrt(1e8)的时候M<=K/sqrt(1e8)=20，这样的确容许我们sort

实际还是TLE了14，把bound改为9000就没问题了

但是这个算法思路不清新，我代码写得也很丑陋（还是尽量重构过的）
看了um_nik的代码，惊叹不已
https://codeforces.com/contest/1535/submission/118430864
完全不需要题解，全凭代码就能看出思路，代码可读性的典范
而且思路也很巧妙，也是用Trie和LCP来思考，但是他注意到了我没注意的一点
那就是用字符串的后缀去构造Trie，但是按照前缀来排序，并且利用LCP的单调性，开单调栈，把原来固定i，O(N)枚举j来check的部分，变成O(M)（因为单调栈中每个元素的与前一位的LCP长度都不等，而字符串总长M是上限）
这样复杂度就不是O(N^2)而是O(NM)，算上二分搜索的复杂度就是O(NMlogN)

这个用单调栈控制复杂度的insight真是巧妙！
实际上um_nik的算法思路就是我原来的思路，只是我没注意O(N)的枚举可以用单调栈去掉一些元素变成O(M)