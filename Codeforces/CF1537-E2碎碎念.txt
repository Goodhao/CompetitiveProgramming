n,k <= 5*10^5

简化操作序列：把删除操作重新理解为取前缀操作，那么每次取前缀的下标>上次取前缀的下标
对于相邻操作都是倍增的情况，我们在中间插入取前缀（全长）操作
这样我们的操作序列总是，取前缀i，倍增，取前缀j，倍增，取前缀k...
i<j<k

设s下标从1开始
假设s1 = s[1]~s[i], s2 = s[1]~s[i] + s[1]~s[i]
也就是说j>i, s2[j]=s[j-i]
如果最优解在s2取了前缀k（2i>=k>i）, 说明有s2[1]~s2[k] + s2[1]~s2[k] < s2 + s2 = s[1]~s[i] + s[1]~s[i] + s[1]~s[i] + s[1]~s[i]

s2[1]~s2[k] = s2[1]~s2[i] + s2[i+1]~s2[k]

s2[1]~s2[k] + s2[1]~s2[k] = s2[1]~s2[i] + s2[i+1]~s2[k] + s2[1]~s2[i] + s2[i+1]~s2[k]
= s[1]~s[i] + s[1]~s[k-i] + s[1]~s[i] + s[1]~s[k-i]

如果 < s[1]~s[i] + s[1]~s[i] + s[1]~s[i] + s[1]~s[i]

（此时一定有k!=2i）说明s[1]~s[k-i] + s[1]~s[i] < s[1]~s[i]

如果这样的话，为什么不一开始取前缀i为k-i<i呢？这样就否定了任何取前缀操作多于两个的方案的最优性

如此说来，我们似乎只有一次取前缀的有效机会

可以把每个前缀i倍增>k删到k的字符串（一个i对应一个这样的字符串）都存入set
然后输出set中最小的字符串

但是我们知道一些前缀i肯定不是最优的，比如s[i+1]<s[0]的前缀，你切掉粘s[0]反而更坏
而对于s[i+1]>=s[0]的字符，最多26种，
假设对于同一个>=s[0]的字符，出现的第一个pos是s[j]>=s[0],第二个pos是s[k]>=s[0]


那么，肯定切第一个

其实这个分类讨论都是多余的

如果s[j]>s[0]，并且1~j-1的s都是<s[0]的，那么这个字符串的最优解一定是取前缀1~j-1，没有别的

如果在第一个s[j]>s[0]之前（或者干脆都<=s[0]），1~j-1的s都是<=s[0]的，等于的情况，和E1的分析一样，一直判断到str的尾巴
如果还是等于，那么选择切掉

复杂度就交给了如何判断后缀和前缀是否相等
可能是KMP算法之类的，反正早忘了。。还是用自动机来思考


似乎就是AC自动机，不断找最大后缀，把下标存到集合里或者hash表里查询
重新造一下轮子，对于s[1]~s[n]，设最大后缀为i，则s[i]~s[n]=s[1]~[n-i+1]
对于s[1]~s[n-1]，设最大后缀为j（如果没有呢？），则s[j]~s[n-1]=s[1]~[n-j]
如果i<j，则
s[i]~s[n]=s[i]~s[j-1] + s[j]~s[n-1]=s[i]~s[j-1] + s[1]~[n-j]=s[1]~[n-i+1]
...drop这个方向了...

回忆一下失配指针
似乎就是这样干

似乎漏掉一个讨论
当s[i+1]==s[0]的时候，如果往后判断发现了s[i+1+k]>s[k]
那么在i+1切掉比起完整保留s更好，但是是否可能切别的点比切i+1更好呢？
不会，优先切前面的点更好

好像不仅要判断后缀前缀是否相等，还要判断后缀是否>还是<前缀
还是先suspend


假设s[j]是第一个>=s[0]的数，那么如果s[j]>s[0]，直接确定前缀
如果s[j]==s[0]，我们往后找，如果后续找的长度<j，就出现了不同位的情况
如果是j开头的字符串>0开头的字符串，那么也是取前缀j
否则<，我们不切j，但是我们也不需要继续用相同的操作来检查j+1，因为
假设第一个k | s[j+k]<s[k]，那么
那么s[j]~s[j+k-1]=s[0]~s[k-1]，而k<j，s[j]是第一个>=s[0]的数字，那么s[1]~s[j-1]都是<s[0]的
因此s[j+1]~s[j+k-1]=s[1]~s[k-1]也都是<s[0]的
所以，p属于[j+1,j+k-1]的时候，去检查p，以p开头的后缀一定不是前缀，根本不用检查

接下来考虑后续找的长度>=j，那么0前缀中==s[0]的个数和以j开头字符串==s[0]的个数相同，且位置对齐，只差一个偏移量j，p属于[j+1,j+k-1]的时候，去检查p，要么s[p]!=s[0]，以p开头的后缀一定不是前缀，根本不用检查，要么s[p]==s[0]，所以p一定是0前缀的第x>1个==s[0]的数，观察发现，这样的p之间构成循环节，所以比较大小还是可以归结到最后一个到长度<j的循环节与0前缀的第一个循环节的比较
转化为上面的推理。