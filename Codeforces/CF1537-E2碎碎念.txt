n,k <= 5*10^5

简化操作序列：把删除操作重新理解为取前缀操作，那么每次取前缀的下标>上次取前缀的下标
对于相邻操作都是倍增的情况，我们在中间插入取前缀（全长）操作
这样我们的操作序列总是，取前缀i，倍增，取前缀j，倍增，取前缀k...
i<j<k

设s下标从1开始
假设s1 = s[1]~s[i], s2 = s[1]~s[i] + s[1]~s[i]
也就是说j>i, s2[j]=s[j-i]
如果最优解在s2取了前缀k（2i>=k>i）, 说明有s2[1]~s2[k] + s2[1]~s2[k] < s2 + s2 = s[1]~s[i] + s[1]~s[i] + s[1]~s[i] + s[1]~s[i]

s2[1]~s2[k] = s2[1]~s2[i] + s2[i+1]~s2[k]

s2[1]~s2[k] + s2[1]~s2[k] = s2[1]~s2[i] + s2[i+1]~s2[k] + s2[1]~s2[i] + s2[i+1]~s2[k]
= s[1]~s[i] + s[1]~s[k-i] + s[1]~s[i] + s[1]~s[k-i]

如果 < s[1]~s[i] + s[1]~s[i] + s[1]~s[i] + s[1]~s[i]

（此时一定有k!=2i）说明s[1]~s[k-i] + s[1]~s[i] < s[1]~s[i]

如果这样的话，为什么不一开始取前缀i为k-i<i呢？这样就否定了任何取前缀操作多于两个的方案的最优性

如此说来，我们似乎只有一次取前缀的有效机会

可以把每个前缀i倍增>k删到k的字符串（一个i对应一个这样的字符串）都存入set
然后输出set中最小的字符串

但是我们知道一些前缀i肯定不是最优的，比如s[i+1]<s[0]的前缀，你切掉粘s[0]反而更坏
而对于s[i+1]>=s[0]的字符，最多26种，
假设对于同一个>=s[0]的字符，出现的第一个pos是s[j]>=s[0],第二个pos是s[k]>=s[0]


那么，肯定切第一个

其实这个分类讨论都是多余的

如果s[j]>s[0]，并且1~j-1的s都是<s[0]的，那么这个字符串的最优解一定是取前缀1~j-1，没有别的

如果在第一个s[j]>s[0]之前（或者干脆都<=s[0]），1~j-1的s都是<=s[0]的，等于的情况，和E1的分析一样，一直判断到str的尾巴
如果还是等于，那么选择切掉

复杂度就交给了如何判断后缀和前缀是否相等
可能是KMP算法之类的，反正早忘了。。还是用自动机来思考


似乎就是AC自动机，不断找最大后缀，把下标存到集合里或者hash表里查询
重新造一下轮子，对于s[1]~s[n]，设最大后缀为i，则s[i]~s[n]=s[1]~[n-i+1]
对于s[1]~s[n-1]，设最大后缀为j（如果没有呢？），则s[j]~s[n-1]=s[1]~[n-j]
如果i<j，则
s[i]~s[n]=s[i]~s[j-1] + s[j]~s[n-1]=s[i]~s[j-1] + s[1]~[n-j]=s[1]~[n-i+1]
...drop这个方向了...

回忆一下失配指针
似乎就是这样干

似乎漏掉一个讨论
当s[i+1]==s[0]的时候，如果往后判断发现了s[i+1+k]>s[k]
那么在i+1切掉比起完整保留s更好，但是是否可能切别的点比切i+1更好呢？

好像不仅要判断后缀前缀是否相等，还要判断后缀是否>还是<前缀
总是先suspend

