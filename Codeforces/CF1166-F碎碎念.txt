
【check】（
	【->】（【问题简化】（【忽略+操作，只保留?操作】），【构造新图】（【同一点x的所有同色边的邻点集合S中所有y之间两两连边】）），
	【复杂度】
） = 【>O(n^2)】 => 【不可行】


【reduce】（【构造新图】（【同一点x的所有同色边的邻点集合S中所有y之间两两连边】））
= 【【潜在语义】= 【原子化操作】（走同色边走两次）】】

【逆向解析】（
【why】(【reduce】（【构造新图】（【同一点x的所有同色边的邻点集合S中所有y之间两两连边】））
= 【【潜在语义】= 【原子化操作】（走同色边走两次）】】)
） = 【可能性】（80%, 这就消除了非标准化描述）


【生成】（【生成】(【原子化操作】) = {【删减多余的操作空间，与模型操作空间一一对应】}）=【算法例子: 网络流建模】

【生成】（【check】(【动令】(【为了让一个颜色为red的入边进入点x后以同样red边出来】) = 【拆点】 --【追令: 详细化】-> 【把一个点拆成c个点，c为颜色数，每个点只连对应颜色的入边与出边】 --【追令：质问】（【c的数量级是10^5，可行吗】）-> 【答令: 可行，我们只要对每个点，按照实际邻边的颜色数拆点即可，这样是sum c = 10^5，被均摊了】) = 【拆点】 with 【满意】)）=【算法X】

【算法X】 --【满足约束】-> 【问题简化】（【忽略+操作，只保留?操作】）
= 【把每个点按照邻边的颜色数拆分成多个点，每个点只接受对应颜色的邻边。设x的拆点集合为[x], ? x y就是查询是否存在点i,j使得新图中[x]的点i到[y]的点j连通】

--【追令】--> 【模式识别】（等价类中的点与点的连接关系）--> 【数据结构: 并查集】
--【移交】--> 【生成】(【算法X】，【并查集】) = 【算法Y】 = 【把每个点按照邻边的颜色数拆分成多个点，每个点只接受对应颜色的邻边。设x的拆点集合为[x], ? x y就是查询是否存在点i,j使得新图中[x]的点i到[y]的点j连通，设置等价类代表元，每个[x]的元素都与代表元连边，若两个[x]和[y]的代表元在并查集中归属相同的集合，那么存在...】

--->代表截断符，中断当前的过程，而转移到另一个触发启动的过程

--【模式识别】->(【余项】(【原问题】，【算法Y】） = 【+操作】, 【数据结构：并查集】) = 【并查集维护动态连通性】
【生成】（【并查集维护动态连通性】，【问题】） = 【给定一张图，允许加边，不能加点，查询任意两点之间的连通性】 --【生成】-> 【这就是并查集本身的功能，本身就是先视整张图为离散点，然后不断动态加点，更新连通性的】 => 【不需要特别改造，直接用并查集】

【生成】(【原问题】with【+操作】，【算法Y】with【直接用并差集】）=【算法Z】=【建图过程：每加入一条边(x,y,c)，就找x和y是否已经有对应颜色c的拆点了，有的话直接连拆点，否则新建拆点再连，期间用并查集维护连通性】

【check】（【算法Y】,【例子1】）=【something wrong: 同[x]的点互相连接的话，就会出现通过[x]的另一点走另一颜色的边，破坏了操作的原子性】

