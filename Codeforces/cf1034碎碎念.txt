
A
题意：
给定2<=N<=3*10^5个整数，
你可以删除一些数字。

求最少的删除次数使得剩下的数字的gcd比原来的gcd大（不要求是所有方案中最大的）


碎碎念：
我们把每个数字的质因数分解数组求出后
找出不是公共的质数，求出有多少数字没有它，记为cnt
我们找出cnt最小的质数，那么删除cnt个数字后就可以拥有更大的gcd，而且这样是最少删除次数

我们求出所有数字的质因数然后混在一起unique之后对每个质因数去统计有多少个数字不含它们

O(N*M) M为总质因数个数
似乎会很大？

我们没必要这样做
我们开一个hash和一个vector
hash[i]统计有多少个数字含有质因数i
vector存所有质因数总数
我们只要求出最大的不等于n的hash[i]，那么n-hash[i]就是我们的答案

暴力对拍
不知道怎么对拍
可以2进制枚举子集

O(N*M) M为<=N的素数个数
M=25997

O(N*M) M为<=sqrt(N)的素数个数
M=101

可以一试

B
题意：
给定n*m的棋盘，你每次可以放两个棋子在棋盘上，满足两个棋子的曼哈顿距离=3
请问你最多可以放多少个棋子

n,m<=10^9

碎碎念：
感觉这是个假范围，一般数论题很容易出现假范围

注意你每次放的两个棋子的曼哈顿距离=3，但是你从最终棋局是看不出来你每次放的是哪两个的

所以给定一个最终棋局，它合法的条件就是我们可以将棋子一一匹配使得匹配的棋子之间的d=3

既然要最多棋子数，那么我们把棋盘全放满是否可行？

如果n,m有一个是6的倍数，那么我们就可以放满一行或者一列从而放满棋盘

以下都是对称情况（可以互换n,m）

n%6==1
m%6==1
最多可放n*m-1个棋子
n%6==1
m%6==1
最多可放n*m-1个棋子
n%6==5
m%6==5
最多可放n*m-1个棋子

不想构造了

对这题前景不抱什么希望

理想状态下我根据剩余类来讨论能够构造出最优策略
但是这样就太没意思了
而且我感觉也不能这样做


C：
题意：
给定N<=10^6的树，每个点都有权值ai=10^9

要求你划分层次（相当于把树的所有节点当作叶子，然后从底层新建出一个树）

满足新构造的树，相同深度的树的权值和相等（权值和就是叶子节点的权值和）

求有多少种这样的树

碎碎念：
感觉这题自由度太大了，不好做啊
一个比较重要的限制就是，对每个深度，同深度的树的权值和相等

那么我们就考虑倒数第二层的树根

假如我构造的树总共3层，第一层只有一个root，最后一层都是叶子
那么我们就相当于把a1~an进行子集划分使得每个子集和相等
求划分方案

感觉连个简单版本都这么难做的样子
我不会做