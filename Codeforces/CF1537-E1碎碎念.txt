1. 删除字符串s末位
2. 倍增s

找到长度恰为k的字典序最小字符串，能被上述对s的操作构造出来


换句话说，在所有操作生成的字符串集合中，取一个长度为k的字符串子集，在其中找
字典序最小的元素

n,k <= 5000


问题：一定能构造出长度为k的字符串吗

可以，虽然倍增的话，长度是初始长度的2^i倍，但是我们只要长度>k后就可以不断把长度-1
得到k长度

我们是该先倍增再删长度，还是先删点长度再倍增呢？
可能不能预先确定，要根据字符串来决定

如果初始字符串是aa，那么顺序无所谓
如果初始字符串是ab，那么先删b后倍增得到的都是aaa，否则就是ababab..
所以似乎顺序与第i位字符 >还是< 第i+1位字符有关

如果字符串首字符是a，那么显然不管后面是什么，都先删光，保留a
再倍增>k，再删到k，得到长度为k的全a串，这样最好

如果是ba，恐怕直接倍增>k，再删尾巴是最好的

所以，现在的做法就是，找到第一个i使得 s[i]<s[i+1]，保留前i个字符，倍增>k，再删到k

不是这样

应该是找到第一个s[i]>s[0]的，取1~i-1位

问题来了，如果s[i]==s[0]呢
继续比较后面的位数
这样是O(N^2)


如果s[i]~s[n-1]都一样呢？
bbaabb

不知道怎么处理呢。。

第一次倍增应该从哪里开始
或者说，第一次倍增前，应该删到哪个前缀、


操作序列是可以化简，并分类的
比如第一次从前缀1~i开始倍增，那么之后一定不会删到i更前面。。否则前面的操作都是白做了，一开始就从j<i的j开始倍增即可
也就是说，我们简化后的操作序列中，第一次倍增的前缀，之后永远不会改变

每次倍增，加的字符串可能不同，但首字符一定是s[0]

假设第一次前缀为i，那么之后倍增新加的长度...


k=1，那么最终字符串一定是s[0]
k=2，最终可能是{s[0]s[0],s[0]s[1]}
k=3，最终可能是{s[0]s[0]s[0],s[0]s[1]s[0],s[0]s[1]s[2]}


也就是说，我们简化后的操作序列中，第一次倍增的前缀，之后永远不会改变，而第二次从j开始倍增，可以视为对新字符串的第一次倍增，对新字符串来说这个前缀j也不会变了
所以，如果我们有方法找到更好的前缀j，那么后续的操作都作废了。


一个构造法，找到第一个s[i]>s[0]，取前缀1~i-1，倍增，继续在新字符串中找第一个s[i]>s[0]，如此重复直到字符串中不存在s[i]>s[0]，或者已经>k，后续就是倍增>k再删到k

扫描一次O(N)，而每次字符串长度一定加一，所以总复杂度是O(N^2)的

好像还是没解决 如果字符串中不存在s[i]>s[0]，如果s[i]~s[n-1]都一样呢？

应该优先切，如果不切的话，就必须从头开始粘前缀，切的话，是从已经重叠了的前缀不算它们，从下一个位置开始粘，而前缀下标越大数字一定是越小（不会更大）的，否则我们可以调整
