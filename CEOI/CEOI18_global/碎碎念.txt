又要写LIS了
我连最原始的LIS问题都还没学熟

原始的LIS
f[i]表示以a[i]结尾的IS的最大长度

f[i]=max{f[j]}+1 for all j<i并且a[j]<a[i]

一个做法就是离线处理+BIT
这个方法我熟练

另一个做法就是把状态改变一下
好像忘了
不过是个机会让我自己重新推理一遍

这里其实也是有二维偏序的影子的
离线处理就是先排序好一维然后处理第二维

另一种方法就是通过修改状态的定义来做一些事情
还有什么状态可以表示出LIS呢？

dp[i]表示长度为i的IS的最小结尾数字，如果不存在就为Inf
这个状态表示有点难以想到，因为我们的LIS不是通过dp的值来得到的
反而是通过维度的参数来体现的

我们依次看数字，当我们看到第i个数字的时候
我们应该已经做出了关于前i-1个数字的dp数组
然后我们要把它更新成关于前i个数字的

注意到我们已经满足了二维偏序的其中一维了，也就是下标的顺序（我们是顺序枚举的）
然后接下来只要找出j<i且a[j]<a[i]的满足有一个IS是以j结尾的，
这样我们就可以得到一个新的以a[i]结尾的IS

这样看似还是要枚举，但是我们要求的是最大的IS，
这个最优性有什么用？

如果i<j那么
dp[i]<dp[j]（假设都不为inf）

这个可以反证

这样子通过最优性我们得到了单调性
然后有了单调性我们就不需要直接枚举了
我们可以二分搜索

我们只需要搜索那些在相同IS长度中数字最小的（这样最容易加上a[i]构成新的IS）
这就是我们已经计算好的dp数组
对于a[i]，我们搜索出最大的小于a[i]的数字，找出它的下标，把下标+1就是我们得到的新的IS

那么对于原来下标+1的位置的数字就改成a[i]



不过还是看f比较便于思考
我们修改一个区间的操作会对f造成什么影响？
如果我们是减少一个区间的数字

如果LIS变大了：
新的LIS的结尾一定在这个区间右边的区间中
因为左边的不受影响，中间的只会不变或者更小
而且新的LIS中一定包含被修改的区间的元素

考虑区间固定的情况：
怎么修改d使得新的LIS最大？

d有范围

感觉这题看似是经典问题的扩展
其实很难

应该从LIS这个东西的特点下手
而不是直接进入本题的难点

子序列的话不要求连续，只要相对次序<
当我们把一个区间的数字减少后

可能会导致以这个区间结尾的LIS长度减少
因为可能原来的LIS在左边的数字会大于你减少后的数字

没什么思路


生成几个数据来分析一下
直接人工生成

如果区间[L,R]是固定的，
我们可以选择增加或者减少
假设我们选择的是减少

那么有可能产生比不做任何操作时候的最大LIS更大的新的LIS的开头
一定只在这个[L,R]中

并且我们减得越多，产生的LIS只会更大或者不变

因此我们就直接减去x，然后对于[L,N]的部分求LIS
然后取max和原来的最大值比较


如果我们选择的是增加：

那么有可能产生比不做任何操作时候的最大LIS更大的新的LIS的结尾（注意是结尾）
一定只在这个[L,R]中

然后我们直接增加x（也和上面一样有单调性）求[1,R]的LIS

这样就解决了区间固定的问题

我们对于固定区间需要O(NlogN)
如果我们枚举所有区间的话
总复杂度是O(N^3logN)

如果我们只枚举区间的左端点
那么我们能否找出最佳的右端点呢？


可以发现，对于增加的操作，最佳的右端点是N!
对于减少的操作，我们改为枚举右端点，最佳的左端点是1!

这样O(N^2logN)

对于增加的操作，
对于选择的区间的左端点i，
我们把它的值增加x，那么以它结尾的LIS=max{f[j]}+1 j<i并且a[j]<a[i]+x
所以我们不需要枚举区间然后单独做LIS

先预处理处原始序列的f
我们从N到1枚举L

我们枚举L的时候计算出经过L的LIS

f表示以i结尾，g表示以i开头的
也就是len1=max{f[j]}+1 j<i并且a[j]<a[i]+x
len2=g[i]
新的LIS总长=len1+len2

重点就是计算len1
还是用离线做法，按照a排序后加入到线段树求max
这里有点不同的是我们枚举i，表示将要计算第i个元素
但是这时候我们加入的元素指针应该已经到p了，p>=i
使得a[1]~a[p]的所有a都<a[i]+x
这样仍然是O(N)
总复杂度是O(NlogN)

这样就可以解决本题了

