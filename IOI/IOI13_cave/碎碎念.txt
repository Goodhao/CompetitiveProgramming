不管询问次数的限制的话

我们2^n枚举所有开关的状态
然后check什么时候返回-1
我们就得到了正确状态

找出正确状态后

我们分别把第i个开关改变，然后返回的关闭的门就是它对应的门

改变一个开关观察返回的门

对于初始序列，我们得到第一个关闭的门的编号x
接下来对于每个i，我们改变它，然后如果返回的不是x了
说明这个i对应的门就是x，并且改变后的状态是它的正确状态

这样可以O(N)确定一个开关和门的对应，一个开关的正确状态

O(N^2)可以做出本题

我们希望有一个O(NlogN)的算法
我们不一个一个地改变
我们二分，一段区间一段区间的改变

对于初始状态，如果第一个门是开的话
我们把状态全取反，则第一个门一定是关的

然后我们二分区间，
对于当前的区间，我们把区间内状态全部取反，如果第一个门变成开的了
说明第一个门对应的开关就在这个区间中，否则就在另一半区间中
然后O(logN)求出对应开关和正确状态
接下来我们要确定第二个门对应的开关，因此要保持第一个门始终开着
所以接下来的取反过程中是把当前区间除了第一个门对应的开关外的开关取反

这样O(NlogN)就解决了本题

我们确定一位的时候用了O(NlogN)因为我们取反要O(N)
这样O(N^2logN)反而更糟糕

等等
你的时间复杂度这么多没关系，询问次数还是O(NlogN)
这就足够了

