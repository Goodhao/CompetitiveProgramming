选和不选看上去像背包

对于一个方案，必定有一个工人拿到恰好是最低工资
否则的话我们把总工资调低，保持每个人比例不变，同样可以满足条件

我们先要满足的条件是工人数量
让工人数量尽可能大

假如说我们不去管工人数量一定的情况下如何让钱最少。

我们只管让工人数量最大

那么我们的总工资=W最好


我们可以枚举工人的子集，然后check，O(N*2^N)

单个工人的工资是由我们所有选择出来的工人组成的整体决定的。
于是我们要枚举子集

假如说Q都一样，那么我们只要把前k个最低工资最低的工人选出来就行了

如果Q不一样，那么给定一种方案，是否可以调整得到更优的方案？
如果A在方案中，B不在
并且QB>=QA,SB<=SA，
那么把A用B代替仍然可行，并且费用不会更多

发现我们用到的全局性质只是sum{Q}
这样的话我们可以用背包的维度来代替枚举子集

f[N][W][K]
表示我们用W块钱，然后我们要选择sum{Q}<=K的工人集合（从1~N中选择）
使得工人最多，f[N][W][K]就是这个工人数

f[N][W][K]=max{f[N-1][W][K], f[N-1][W-Q(N)/K*S(N)][K-Q[N)]}

这样的话要O(N*W*sum{Qk})

把W放在维度就铁定不行啊


QB>=QA,SB<=SA
这个东西好像二维偏序啊

我们把工人按照Q的大小排序

关键还是不预先知道sum{Q}的话就没法计算单个工人的工资


我们似乎可以建立图论模型啊

先随机一些数据自己手算

发现可取的工人数是具有单调性的
如果我们有一个方案包含了x个工人
那么我们从中删除任意多个工人后的方案仍然是合法的

所以找最大工人数可以二分然后check

W*Qi/sum{Q}>=Si
W/sum{Q}>=Si/Qi
右边可以单独处理

然后我们枚举sum{Q}，当然我们是二分地枚举

对于所有满足条件的i
如果个数<x，那么一定不可行
如果个数>=x，那么我们取其中Q最小的前x个
如果这些Q加起来<=我们枚举的sum{Q}，说明可行
否则不可行

这样的话可以O(N*(logN)^2)求出最大工人数

如果最大工人数是x
假如我们已经固定了sum{Q}
那么让W最小，只要取出Si/Qi最小的x个，然后x个里用最大的Si/Qi乘上sum{Q}就是
我们的最小W

问题是这x个Si/Qi的sumQi不一定<=固定的sum{Q}

我们可以固定sum{Q}，枚举最大的Si/Qi的i
直接计算出W，然后check
方法是对于所有Si/Qi<=我们枚举出的那个数字的i中取出Q最小的x-1个
如果这些Q包括之前枚举的i的Q加起来<=sum{Q}就可行

我们把顺序改一改，先枚举出最大的Si/Qi，再枚举sum{Q}
check的方法不变，可以发现sum{Q}越大，W也越大，因此我们希望sum{Q}尽量小
也就是在所有可行的sum{Q}中找最小的
发现这是单调的，也就是说对于>可行的最小sum{Q}的sum{Q}，都是可行的！

然后check的过程可以预处理，通过堆来实现
