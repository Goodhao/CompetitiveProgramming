小明摆放的图案中的方块数可以自行决定（也就是整个图案的边长只要是方块的奇数倍数即可）

设倍数为d

那么对于一个倍数为d-2的图案，中心点
假设给定的点的位置也在其中

那么我们对这两个东西的处理有什么区别？

如果M给你了，你怎么求中心点？

对于一个方块，M给你，给了方块的其中一个位置(x,y)，你怎么求这个方块的中心点？

注意到只要控制x和y其中一个不变，另一个增加或者减少<=M，所得到的点要么仍在这个方块中
要么会落到不涂色的地方，不会落到另外一个方块中

设偏移量为D，1<=D<=M
我们二分D，然后分别从(x,y)上下左右移动D格，对于这四个点，如果全部为空白
那么把D减少，如果有多于一个点是涂色的，那么把D增加
这样找到第一个D使得恰有一个点是涂色的

如果这个点是向下移动的，说明(x,y)处在方格的上半部分
其余情况类似推理

然后继续找第二个涂色的点。

等等
不用这么麻烦

我们四个方向单独处理，每次二分D（D初始=M），找出恰好使得移动D后得到涂色格子
那么D就是(x,y)到这个方向的边界的距离
这样确定了四个边界的位置，从而确定该方块的中心点
（如果M为偶数就没有中心点，但是题目保证M为奇数）

方块的中心点确定之后，对于整个图案，用类似的方法找出整个图案的中心点（从原来方块的中心点出发二分D）

于是现在的问题就是M未知
考虑一维的问题
你有一些长度为M的区间，每个区间之间相隔M个空格
你有一个被涂色的点
你需要请求几次来确定M

二分不可行的原因就是你第一次可能太过反而落点另外一个区间上，无法确定是否仍在原来区间中
就确定不了原来区间的长度

可以倍增
先Len=1
然后把原来的点+len，
如果仍然涂色
就len+=2

len+=4..
len+=2^n

这样一旦遇到空格，必定是原来区间紧接着后面的空区间

然后把D设为这个len，再二分
中间就不会有别的涂色区间存在了

可以最多31次就确定len
二分的话也最多31次
每个方向都重复一遍，4*2*31确定方格中心点
然后把方格中心点当成(x,y)类似重复一遍
2*4*2*31=496次

可是最多让你问300次

不需要四个方向都做一遍，只要做3个方向即可

2*3*2*31=372

然后把方格中心点当成(x,y)再做的时候
我们是M倍数的改变D的，所以次数应该是log(N/M)
加起来应该是
log(N)*3*2可行
（发现估计的不对，但是应该是<=300的）
