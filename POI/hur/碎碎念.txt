感觉是个DP
是个背包DP

f[i][j]表示现在是第i天，早上进货前货物还有j个
在这个条件下的在i~n天内最多能满足的天数

f[i][j]=max(f[i+1][j+a[i]],f[i+1][j+a[i]-b[i]]+1] if j+a[i]>=b[i])

这样的话复杂度是O(N*V)
V是货物总和
V太大了，不可行

应该是有一些性质可以分析出来

假设我们已经有了一个方案了，如何调整？

如果我们满足了第i天却没有满足第i+1天
并且b[i]>=b[i+1]，那么我们可以改成满足第i+1天而不满足第i天

假设b是单调不增
那么我们的方案一定可以调整为后缀天
于是我们只要枚举长度然后验证

假设我们枚举后缀的第一个位置是x
那么我们需要满足：
sum_a(x)-b[x]>=0
sum_a(x+1)-b[x]-b[x+1]>=0

也就是对于k=0,...,n-x
sum_a(x+k)-sum_b(x+k)-sum_b(x-1)>=0

看题解了

发现算法是这样的
我们从左往右依次看，每看到一个可以取的，也就是当前的货物量>=b[i]的
就把当前的需求给取下来，否则如果当前的货物量<b[i]，
并且我们之前取下来的需求中有一个b是>=b[i]的，我们就把原来的那个b删除，改成满足当前的b[i]
这个过程可以通过维护之前元素的堆来实现

其实这个性质已经被我发现了，但是我没有因此构造出这样的算法
应该说我潜意识里认为正确的做法应该是DP

那么如何证明这个算法的正确性呢？
这个算法是贪心的构造法
我们每次都尽量取，如果都取了，这样每一步的贡献都是最大的
遇到第一个需求i不能取的时候，那么1~i肯定不能全取，
我们的做法中，如果可以替换就替换，这样也是最优的，也就是说在需求数不变的情况下，让花费尽量少
如果不能替换，也是最优，毕竟i不可能达到，但是i-1达到了，费用也不可能更小了

然后继续去取取取，遇到第二个需求i不能满足的时候
那么我们也不可能达到更好的结果了（在满足天数上），
我们可以归纳假设我们的算法在执行完第i天的时候1~i的满足天数都是最优的，并且花费是多种最优方案中最少的
现在对于i-1天是这样的，然后第i天不能被满足
如果新的方案不取第i天，那么这样的方案就是我们的最优方案
如果新的方案取了第i天，并且比我们的结果要好（或者满足天数不变，花费更少），说明i-1天可以达到更好的结果，与我们的假设矛盾

所以我们的算法是正确的

