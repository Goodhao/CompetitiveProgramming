
11分
M<=10,N<=1000
这个可以枚举子集然后check O(2^M*N*M)
复杂度还是有点大，不过我们可以剪枝一下

可以留着暴力

选择挡板，就是背包DP

f[i][s]表示正在考虑是否选择第i+1行的挡板，其中上一行（第i行）的所有落点位置用s表示
f[m+2][s]的话就强制不选择挡板，因为没有了

最终的目标就是min f[m+2][s] 其中s为所有只含一个元素的集合

这个做法是O(M*2^N)
但是N很大，不可行

假设我们已经选择好了挡板了
然后我们依次看每一行小球可能出现的落点位置，用N位2进制表示
第1行
111111111
第2行，假如没选择这行的挡板，那么也是111111111
如果选择了，那么如果挡板的区间在上一个状态中包含至少一个1
那么新的状态就是把该区间的1改成0后再把孔的位置上改成1
如果挡板的区间在上一个状态中不包含1，那么新的状态就是把该区间的1改成0

第3行类似处理
第m+2行的时候状态应该只包含1个1了

如果我们检查我们的方案，依次把小球执行下去，如果到第i行（i<m+1）的时候落点已经变成唯一的了
接下来的挡板我们都不用选取。

如果我们的落点不唯一，并且有1个落点不被下面任何一个挡板覆盖，那么这个方案一定不可行

如果我们的落点不唯一，并且所有落点都被至少一个挡板覆盖，那么我们在这些落点上同时放小球开始下落
一定会在某一个挡板上收集到所有小球，一定是逐步合并的

这个合并的过程像一颗底部为根的树

这样的话，如果第i行区间和第j行(j>i)区间相交，我们就连一条有向边(i,j)

这样我们的最终方案一定是一颗有向树，树边方向都朝下

为了使得小球落点唯一，我们的最左端点和最右端点的区间以及内部区间的并集要等于
[1,n]


是否可以贪心？

把挡板按照权值从大到小排序，然后尝试删除，当无法删除的时候剩下的挡板全部取

反例：想出来了



每个行只有一个挡板，这个是该问题比较特别的地方。
按照我们建立的模型，不一定要限制每行只有一个挡板

先随机一些数据看看？

假设我们的每个挡板的花费都是一样的，那么就变成要求挡板数目最小

所有挡板的并集一定是覆盖[1,n]的否则落点不可能唯一（除非n=1，但是保证了N>=2）

挡板和孔

M=1的时候，显然必须要取这个挡板，并且取了必定能保证落点唯一（我们已经通过假设加上了一些条件）
M=2的时候，如果挡板1或者挡板2都格子可以覆盖整个区间，只要取其中1个
否则全取



似乎可以换个问题，不关心孔了，
如何用最少的花费使得我们取的区间的并集覆盖[1,n]
这样的话挡板之间的上下关系可以忽略，这样我们就可以排序，
按照左端点排序
然后从左往右依次看挡板

把端点离散化之后DP
怎么转移呢？
f[i]表示我们要选取一些区间来覆盖端点i到最后一个端点之间的区间
哪些区间我们可以选呢？所有左端点<=i并且右端点>i的区间是我们可以选择的区间

这样可以O(M^2)完成计算

发现自己想错的一个地方
我以为建图没法解决问题是因为我们要满足最终选择的区间能够让小球一直落下到指定位置
这样没法单纯用建图来解决

其实如果A->B的话，就说明B的挡板可以接住A的孔下落的小球
这样A和B的区间一定也是相交的

这样的话如果我们选择一个挡板为根，找一个有向子树（不一定是生成树，也就是说不一定包含所有点）

并且方案中包含了区间[1,*]和[*,n]的两个挡板，那么这个方案就是合法的

而且我们似乎只需要[1,*]到root的路径上的挡板和[*,n]到root路径上的挡板，其余的可以扔掉
这样的话我们只要枚举root,[1,*],[*,n]就行了 

没错

利用最小树形图不固定根的技巧
我们可以省去枚举root的过程，只用枚举[1,*] ,[*,n]
然后check和计算代价
O(M^3)

这样有30分

而且注意到我们的树其实只有两个枝条，只在root处相交

如果在之前就相交，那么接下来的点都不用取了

因此我们可以分开独立处理[1,*]和[*,n]
O(M^2)

似乎有点问题

注意到我们的图是DAG！不含环
因此我们可以O(M^2)计算两个挡板之间的最短路
然后我们枚举root
接下来就不用直接枚举[1,*]和[*,n]（以下为了方便称为左板和右板）

我们直接取出到它最近的那个左板和右板就行了，我们说过这是独立的
这样虽然可能在root之间路径就相交了，但是不会漏掉最优解
只要O(M^2)

注意我们只需要用到的是左右板到某个挡板之间的最短路
所以可以加两个超级源，变成单源最短路

不过边数是O(M^2)的

就不能直接连边建图

我们一行一行考虑
每行只有一个挡板
每次我们计算出1~i行每行挡板的左最短路和右最短路

对于第i+1行挡板
它的左最短路就是在所有与它相连的挡板中取最小的左最短路，
因为这里的最短路是点权最短路，所以不管从哪个点进来都一样
都加上当前点的点权

而与它相连的挡板都是满足孔在这个挡板之间的
我们可以把每个挡板的孔、左右端点，离散化后用线段树维护最值

这样就是O(MlogM)的了
可以AC