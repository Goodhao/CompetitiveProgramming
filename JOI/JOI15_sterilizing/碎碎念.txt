这是个裸的数据结构题
感觉应该是应用线段树来解决的

如果没有操作2的话
问题就是经典的线段树问题

我们发现有10分K=1，相当于没做操作2

k非常小应该有用处

我们是不是想错了，不应该用线段树
我们应该离线处理

发现还有5分可以直接模拟
所以你可以用线段树+模拟拿15分

假如说所有区间都不相交的话你可以直接模拟

我们把每个询问都打上编号
然后按照l排序，相同按照r排序

一个数字先/a取整后再/b
和/ab再取整有没有区别？

感觉是没有区别的


如果操作3只有一次，而且是最后一次：
我们就可以用线段树区间加法（一次操作2就把辅助区间的+1，初始为0）和区间修改的方法来处理

对于操作1，我们要有所改变，使得它是在执行完它上面的所有除法后=我们要求的目标数字

但是还是处理不了操作3

还是要离线处理吗

发现对于不被任何询问区间覆盖的点，我们对它执行不执行除法都是无关紧要的
反正不会统计它

想到一个离线做法

把每个询问按照时间编号后按我们之前说的方式排序

然后对于每个端点（我们把所有端点排序后一个个枚举）
如果不是任何操作3的区间的左端点，那么我们就可以把这个端点上（如果有）的所有操作1和操作2
的区间（以该点为左端点）的左端点都右移一位

如果是至少一个操作3的区间左端点，那么我们按照时间枚举以它为左端点的区间
不断执行，然后把每个区间的左端点都右移一位。

这样是O(N^2)
但是和直接模拟不同的是我们角度换了，从单个数值的变化入手

发现我们也没有必要单个数值地看
我们把相邻端点的区间成为一段
我们一段一段地枚举（也就是说枚举下一个端点）

然后我们也不需要显式地修改区间
我们在区间的左端点枚举到的时候把它的右端点加入到队列中，当我们枚举到它的右端点的时候会把它退出队列
这样在队列中的区间都是覆盖了当前点的区间

我们计算贡献的时候集体打标记，退队的时候再结算

给队列打标记。好像是对队列做线段树的样子

发现不对

k这么小到底有什么用？
k<=10也太小了

现在想了48分钟
估计读题花了5分钟

发现我们其实是可以用线段树处理的

假设我们的除法是精确除法不是取整的，然后我们的线段树存放
某段区间的和（double值）

这样执行除法操作就直接对分解区间，然后对于那些seg[k]执行除法就行了。
打标记，这样修改的时候下传标记。

这样就是O(NlogN)
不过线段树可以做，那么离线也应该可以做？

现在的问题就是我们的除法是下取整的
就不能直接对sum做除法

k很小，那么我们可以存放不同sum，

对于一段区间的sum[i]表示这些区间里所有mod k=i的数字之和
cnt[i]为这些数字的个数

这样我们除k的时候，对于sum[i]，它对新的S（这个区间所有数字之和）
的贡献就是(sum[i]-i*cnt[i])/k

可是这样不能计算出新的sum[i],cnt[i]

我们对区间内的每个数字都预处理好它/k,/k/k,...,/k/k/k..的结果
如果k不等于1的话最多有每个位置最多O(log(10^9)个数字

感觉没有什么用
看题解了

看上去不仅用lazy tag的方式维护标记，还维护了当前区间继续除k的一系列sum
感觉我离正解就差一步，就是没想到把这些sum用lazy tag的方式维护

然后合并也就是普通的合并就可以了

代码实现：
query 负责求和
change 负责修改点权
spray 负责除法，实际上是打lazy tag和维护附加信息
update 把当前的点的附加信息用它的儿子来更新
down 把当前的点的标记下传，附加信息删除
queue 队列存放附加信息

为什么要队列，直接用一个数字来表示当前点的sum不可以吗？

不可以，当你执行spray操作的时候，你需要知道某个区间执行除法后的sum，而这个不简单等于
sum/k，因此你只存sum是得不到结果的，或许你可以把问题继续下传交给儿子节点
但是这样就不会O(logN)了，因为你的下传路径可能会一直分叉

而你存好队列之后，执行spray就直接把当前区间的队列弹出一个就行了，之后的队头就是答案
你的儿子节点暂时不做修改，只需要打个tag

我自己最初想的时候局限在
一个区间可能被局部地修改了3次，同时在另一个局部又修改了2次
这样的话你即使最开始计算出所有区间执行i次spray也没用
因为最后发现自己的区间不是完整执行的，那么只能调用儿子来分解到完整区间
可是这样会出现多路分解不是O(logN)的

然后正解的突破性在于
它的队列存放的并不是这个区间从初始状态开始完整地执行i次spray后的和
而是从“当前状态”开始完整地执行i此spray后的和。

这个当前状态可能就是不完整地局部修改造成的，但是我们不管我们之前怎么求得这个当前状态的，
只要我们有了，并且也有了接下来完整地执行若干次spray的值
我们所有的信息都可以自我维护起来。

比如我们接下来要完整spray当前区间，我们就直接弹出队头
如果要修改当前区间的某一部分，我们就删除队列，然后传递给儿子处理，接下来再利用儿子的队列
合并得到当前区间的新的队列。这样是O(logN)，不会出现多路传递。

然后我们发现我们可以从初始状态开始每次操作都维护好这样的信息
那么我们就可以做出本题了

这种先假设我们具有这样的信息，然后发现我们此后可以一直维护下去。
然后发现我们可以得到边界信息。这样就补全整个思路。

可以概括为从中间状态出发往两边想。