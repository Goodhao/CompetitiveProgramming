首先O(N^3)可以保证正确
枚举单词对O(N^2)然后比较O(K)

不过本题似乎是要用Trie的

怎么用Trie来比较两个字符串是否相似呢？
感觉还是很困难啊

现在的问题就是我们比较两个字符串是否相似是需要O(N)的
但是这样的话问题其实不一定要限制相似只允许两个不同
它允许更多位不同也没关系，反正我们只是++cnt

问题只允许最多两位不同说明这里面有什么东西可以被我们利用

我们把问题改成最多允许一位不同

那么我们可以对一个字符串，生成把某一位字符删除后的字符串的hash
对于一个字符串我们求出K个这样的hash
然后要找与它相似的字符串，它对应的hash值被统计的次数>这个字符串K个的hash值计算到当前hash内的次数
那么就说明有与它相似的

我们只要预处理出前缀hash和后缀hash
那么中间删除掉一个字符后的字符串的hash值可以通过前缀hash和后缀hash计算出

这样O(K)就可以求出一个字符串的每一位被删除后的hash
然后对O(N)个都这样做
O(T*N*K)=3*10^5


如果允许两位不同
用之前的做法的话需要生成O(K^2)个hash（对每个字符串）
这样就不行

如果我们只枚举两个不同位置中的最左边的位置pos
那么如果字符串A和B是恰有2位不同
那么要么A[1~pos-1]=B[1~pos-1]要么A[pos+1~K]=B[pos+1~k]
这样的话前缀和后缀必定有一个是相同的

那么对于前缀相同的我们划分到一组内

这样随着pos的增加，同一组会逐渐分裂成不同组
（但是不会把别的组的元素加进来）

我们hash只要求出前缀就可以差分得到某段区间的hash

我们枚举出pos后先把所有字符串按照前缀划分组

然后我们计算出那些前缀相同但是后缀最多相差一个位的字符串，|=1

然后再把所有字符串按照后缀划分组类似做一遍

我们先不管只能至少替换两个位才能从别的字符串生成过来的字符串

先把可以替换一位得到的字符串求出来起

然后再处理后者

这样我们只需要关注只能恰有2位被代替才能生成别的字符串的那些字符串

我们是否可以在Trie上递归处理？
如果说对于字符串A，它可以被B替换2位得到，并且其中一位是第一位

那么我们把所有字符串去掉第一位，然后去找与A’相差恰好一位的字符串是否存在
这就是我们之前处理的问题

似乎这个问题和另一个问题有关系

感觉可以在Trie上做lca呢？
我们想在O(N*K)的时间内对字符串的每个前缀都求出它是0还是1（把相似性修改成最多一位不同）

固定长度为L
如果前缀A和前缀B是相似的，那么他们在Trie要么是同一个节点
要么就是仅仅在lca(A,B)的儿子节点处不同
所以我们不需要O(K)来比较它们是否相似
只需要预处理出Trie上x到fa[x][i]处的hash值
就可以O(logK)时间内比较

不过这样的比较是两两之间比较

放弃了

N*K<=3*10^4
然后分N>K和N<K来讨论
max(N,K)>=173
min(N,K)<=173

这个思路太神奇了
感觉这是数论题里面的思路

对于N>K:
我们可以弄一个O(N*K^2)的算法

首先O(N*K)预处理每个字符串的前缀hash
然后O(K^2)枚举两个位置，
对所有字符串生成去掉这两个位置后的hash值
统计，对于对应cnt>=2的字符串，|=1

这样就是O(N*K^2)

对于N<K:
我们可以弄一个O(N^2*K)的算法
我们直接两两比较就行了！
